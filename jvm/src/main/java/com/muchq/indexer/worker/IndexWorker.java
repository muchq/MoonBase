package com.muchq.indexer.worker;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.muchq.chess_com_api.ChessClient;
import com.muchq.chess_com_api.GamesResponse;
import com.muchq.chess_com_api.PlayedGame;
import com.muchq.indexer.db.GameFeatureDao;
import com.muchq.indexer.db.IndexingRequestDao;
import com.muchq.indexer.engine.FeatureExtractor;
import com.muchq.indexer.engine.model.GameFeatures;
import com.muchq.indexer.engine.model.Motif;
import com.muchq.indexer.queue.IndexMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Instant;
import java.time.YearMonth;
import java.time.format.DateTimeFormatter;
import java.util.Map;
import java.util.Optional;

public class IndexWorker {
    private static final Logger LOG = LoggerFactory.getLogger(IndexWorker.class);
    private static final DateTimeFormatter MONTH_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM");

    private final ChessClient chessClient;
    private final FeatureExtractor featureExtractor;
    private final IndexingRequestDao requestDao;
    private final GameFeatureDao gameFeatureDao;
    private final ObjectMapper objectMapper;

    public IndexWorker(
            ChessClient chessClient,
            FeatureExtractor featureExtractor,
            IndexingRequestDao requestDao,
            GameFeatureDao gameFeatureDao,
            ObjectMapper objectMapper) {
        this.chessClient = chessClient;
        this.featureExtractor = featureExtractor;
        this.requestDao = requestDao;
        this.gameFeatureDao = gameFeatureDao;
        this.objectMapper = objectMapper;
    }

    public void process(IndexMessage message) {
        LOG.info("Processing index request {} for player={} platform={}",
                message.requestId(), message.player(), message.platform());

        try {
            requestDao.updateStatus(message.requestId(), "PROCESSING", null, 0);

            YearMonth start = YearMonth.parse(message.startMonth(), MONTH_FORMAT);
            YearMonth end = YearMonth.parse(message.endMonth(), MONTH_FORMAT);
            int totalIndexed = 0;

            for (YearMonth month = start; !month.isAfter(end); month = month.plusMonths(1)) {
                Optional<GamesResponse> response = chessClient.fetchGames(message.player(), month);
                if (response.isEmpty()) {
                    LOG.warn("No games found for player={} month={}", message.player(), month);
                    continue;
                }

                for (PlayedGame game : response.get().games()) {
                    try {
                        indexGame(message, game);
                        totalIndexed++;
                    } catch (Exception e) {
                        LOG.warn("Failed to index game {}", game.url(), e);
                    }
                }

                requestDao.updateStatus(message.requestId(), "PROCESSING", null, totalIndexed);
            }

            requestDao.updateStatus(message.requestId(), "COMPLETED", null, totalIndexed);
            LOG.info("Completed indexing request {} with {} games", message.requestId(), totalIndexed);
        } catch (Exception e) {
            LOG.error("Failed to process index request {}", message.requestId(), e);
            requestDao.updateStatus(message.requestId(), "FAILED", e.getMessage(), 0);
        }
    }

    private void indexGame(IndexMessage message, PlayedGame game) {
        GameFeatures features = featureExtractor.extract(game.pgn());

        String motifsJson;
        try {
            motifsJson = objectMapper.writeValueAsString(features.occurrences());
        } catch (JsonProcessingException e) {
            motifsJson = "{}";
        }

        String result = determineResult(game);

        GameFeatureDao.GameFeatureRow row = new GameFeatureDao.GameFeatureRow(
                null, // id generated by DB
                message.requestId(),
                game.url(),
                message.platform(),
                game.whiteResult() != null ? game.whiteResult().username() : null,
                game.blackResult() != null ? game.blackResult().username() : null,
                game.whiteResult() != null ? Integer.valueOf(game.whiteResult().rating()) : null,
                game.blackResult() != null ? Integer.valueOf(game.blackResult().rating()) : null,
                game.timeClass(),
                game.eco(),
                result,
                game.endTime(),
                features.numMoves(),
                features.hasMotif(Motif.PIN),
                features.hasMotif(Motif.CROSS_PIN),
                features.hasMotif(Motif.FORK),
                features.hasMotif(Motif.SKEWER),
                features.hasMotif(Motif.DISCOVERED_ATTACK),
                motifsJson,
                game.pgn()
        );

        gameFeatureDao.insert(row);
    }

    private String determineResult(PlayedGame game) {
        if (game.whiteResult() != null && game.whiteResult().result() != null) {
            return game.whiteResult().result();
        }
        return "unknown";
    }
}
