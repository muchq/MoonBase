package com.muchq.indexer.worker;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.muchq.chess_com_api.ChessClient;
import com.muchq.chess_com_api.GamesResponse;
import com.muchq.chess_com_api.PlayedGame;
import com.muchq.indexer.db.GameFeatureStore;
import com.muchq.indexer.db.IndexingRequestStore;
import com.muchq.indexer.engine.FeatureExtractor;
import com.muchq.indexer.engine.model.GameFeatures;
import com.muchq.indexer.engine.model.Motif;
import com.muchq.indexer.queue.IndexMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Instant;
import java.time.YearMonth;
import java.time.format.DateTimeFormatter;
import java.util.Map;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class IndexWorker {
    private static final Logger LOG = LoggerFactory.getLogger(IndexWorker.class);
    private static final DateTimeFormatter MONTH_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM");
    private static final Pattern ECO_PATTERN = Pattern.compile("\\[ECO\\s+\"([^\"]+)\"\\]");

    private final ChessClient chessClient;
    private final FeatureExtractor featureExtractor;
    private final IndexingRequestStore requestStore;
    private final GameFeatureStore gameFeatureStore;
    private final ObjectMapper objectMapper;

    public IndexWorker(
            ChessClient chessClient,
            FeatureExtractor featureExtractor,
            IndexingRequestStore requestStore,
            GameFeatureStore gameFeatureStore,
            ObjectMapper objectMapper) {
        this.chessClient = chessClient;
        this.featureExtractor = featureExtractor;
        this.requestStore = requestStore;
        this.gameFeatureStore = gameFeatureStore;
        this.objectMapper = objectMapper;
    }

    public void process(IndexMessage message) {
        LOG.info("Processing index request {} for player={} platform={}",
                message.requestId(), message.player(), message.platform());

        try {
            requestStore.updateStatus(message.requestId(), "PROCESSING", null, 0);

            YearMonth start = YearMonth.parse(message.startMonth(), MONTH_FORMAT);
            YearMonth end = YearMonth.parse(message.endMonth(), MONTH_FORMAT);
            int totalIndexed = 0;

            for (YearMonth month = start; !month.isAfter(end); month = month.plusMonths(1)) {
                Optional<GamesResponse> response = chessClient.fetchGames(message.player(), month);
                if (response.isEmpty()) {
                    LOG.warn("No games found for player={} month={}", message.player(), month);
                    continue;
                }

                for (PlayedGame game : response.get().games()) {
                    try {
                        indexGame(message, game);
                        totalIndexed++;
                    } catch (Exception e) {
                        LOG.warn("Failed to index game {}", game.url(), e);
                    }
                }

                requestStore.updateStatus(message.requestId(), "PROCESSING", null, totalIndexed);
            }

            requestStore.updateStatus(message.requestId(), "COMPLETED", null, totalIndexed);
            LOG.info("Completed indexing request {} with {} games", message.requestId(), totalIndexed);
        } catch (Exception e) {
            LOG.error("Failed to process index request {}", message.requestId(), e);
            requestStore.updateStatus(message.requestId(), "FAILED", e.getMessage(), 0);
        }
    }

    private void indexGame(IndexMessage message, PlayedGame game) {
        GameFeatures features = featureExtractor.extract(game.pgn());

        String motifsJson;
        try {
            motifsJson = objectMapper.writeValueAsString(features.occurrences());
        } catch (JsonProcessingException e) {
            motifsJson = "{}";
        }

        String result = determineResult(game);

        GameFeatureStore.GameFeature row = new GameFeatureStore.GameFeature(
                null, // id generated by DB
                message.requestId(),
                game.url(),
                message.platform(),
                game.whiteResult() != null ? game.whiteResult().username() : null,
                game.blackResult() != null ? game.blackResult().username() : null,
                game.whiteResult() != null ? Integer.valueOf(game.whiteResult().rating()) : null,
                game.blackResult() != null ? Integer.valueOf(game.blackResult().rating()) : null,
                game.timeClass(),
                extractEcoFromPgn(game.pgn()),
                result,
                game.endTime(),
                features.numMoves(),
                features.hasMotif(Motif.PIN),
                features.hasMotif(Motif.CROSS_PIN),
                features.hasMotif(Motif.FORK),
                features.hasMotif(Motif.SKEWER),
                features.hasMotif(Motif.DISCOVERED_ATTACK),
                motifsJson,
                game.pgn()
        );

        gameFeatureStore.insert(row);
    }

    private String determineResult(PlayedGame game) {
        String whiteResult = game.whiteResult() != null ? game.whiteResult().result() : null;
        String blackResult = game.blackResult() != null ? game.blackResult().result() : null;

        if (whiteResult == null && blackResult == null) {
            return "unknown";
        }

        // Winning results for the player
        if ("win".equals(whiteResult)) {
            return "1-0";  // White wins
        }
        if ("win".equals(blackResult)) {
            return "0-1";  // Black wins
        }

        // Draw results
        if (isDrawResult(whiteResult) || isDrawResult(blackResult)) {
            return "1/2-1/2";
        }

        // If white lost (resigned, checkmated, timeout, etc.), black won
        if (isLossResult(whiteResult)) {
            return "0-1";
        }
        // If black lost, white won
        if (isLossResult(blackResult)) {
            return "1-0";
        }

        return "unknown";
    }

    private boolean isDrawResult(String result) {
        if (result == null) return false;
        return result.equals("agreed") || result.equals("repetition") ||
               result.equals("stalemate") || result.equals("insufficient") ||
               result.equals("50move") || result.equals("timevsinsufficient") ||
               result.equals("drawn");
    }

    private boolean isLossResult(String result) {
        if (result == null) return false;
        return result.equals("resigned") || result.equals("checkmated") ||
               result.equals("timeout") || result.equals("abandoned") ||
               result.equals("lose");
    }

    private String extractEcoFromPgn(String pgn) {
        Matcher m = ECO_PATTERN.matcher(pgn);
        return m.find() ? m.group(1) : null;
    }
}
