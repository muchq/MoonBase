package com.muchq.games.one_d4.worker;

import com.muchq.games.chess_com_client.ChessClient;
import com.muchq.games.chess_com_client.GamesResponse;
import com.muchq.games.chess_com_client.PlayedGame;
import com.muchq.games.one_d4.api.dto.GameFeature;
import com.muchq.games.one_d4.db.GameFeatureStore;
import com.muchq.games.one_d4.db.IndexedPeriodStore;
import com.muchq.games.one_d4.db.IndexingRequestStore;
import com.muchq.games.one_d4.engine.FeatureExtractor;
import com.muchq.games.one_d4.engine.model.GameFeatures;
import com.muchq.games.one_d4.queue.IndexMessage;
import java.time.Instant;
import java.time.YearMonth;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class IndexWorker {
  private static final Logger LOG = LoggerFactory.getLogger(IndexWorker.class);
  private static final DateTimeFormatter MONTH_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM");
  private static final Pattern ECO_PATTERN = Pattern.compile("\\[ECO\\s+\"([^\"]+)\"\\]");

  private final ChessClient chessClient;
  private final FeatureExtractor featureExtractor;
  private final IndexingRequestStore requestStore;
  private final GameFeatureStore gameFeatureStore;
  private final IndexedPeriodStore periodStore;

  public IndexWorker(
      ChessClient chessClient,
      FeatureExtractor featureExtractor,
      IndexingRequestStore requestStore,
      GameFeatureStore gameFeatureStore,
      IndexedPeriodStore periodStore) {
    this.chessClient = chessClient;
    this.featureExtractor = featureExtractor;
    this.requestStore = requestStore;
    this.gameFeatureStore = gameFeatureStore;
    this.periodStore = periodStore;
  }

  public void process(IndexMessage message) {
    LOG.info(
        "Processing index request {} for player={} platform={}",
        message.requestId(),
        message.player(),
        message.platform());

    try {
      requestStore.updateStatus(message.requestId(), "PROCESSING", null, 0);

      YearMonth start = YearMonth.parse(message.startMonth(), MONTH_FORMAT);
      YearMonth end = YearMonth.parse(message.endMonth(), MONTH_FORMAT);
      int totalIndexed = 0;

      for (YearMonth month = start; !month.isAfter(end); month = month.plusMonths(1)) {
        String monthStr = month.format(MONTH_FORMAT);
        Optional<IndexedPeriodStore.IndexedPeriod> cached =
            periodStore.findCompletePeriod(message.player(), message.platform(), monthStr);
        if (cached.isPresent()) {
          int count = cached.get().gamesCount();
          totalIndexed += count;
          LOG.debug(
              "Skipping fetch for player={} platform={} month={} (cached, games={})",
              message.player(),
              message.platform(),
              monthStr,
              count);
          requestStore.updateStatus(message.requestId(), "PROCESSING", null, totalIndexed);
          continue;
        }

        Optional<GamesResponse> response = chessClient.fetchGames(message.player(), month);
        if (response.isEmpty()) {
          LOG.warn("No games found for player={} month={}", message.player(), month);
          continue;
        }

        int monthCount = 0;
        for (PlayedGame game : response.get().games()) {
          if (!message.includeBullet() && "bullet".equals(game.timeClass())) {
            continue;
          }
          try {
            indexGame(message, game);
            monthCount++;
            totalIndexed++;
            if (totalIndexed % 10 == 0) {
              requestStore.updateStatus(message.requestId(), "PROCESSING", null, totalIndexed);
            }
          } catch (Exception e) {
            LOG.warn("Failed to index game {}", game.url(), e);
          }
        }
        Instant fetchedAt = Instant.now();
        Instant firstDayNextMonth =
            month.plusMonths(1).atDay(1).atStartOfDay(ZoneOffset.UTC).toInstant();
        boolean isComplete = !fetchedAt.isBefore(firstDayNextMonth);
        periodStore.upsertPeriod(
            message.player(), message.platform(), monthStr, fetchedAt, isComplete, monthCount);
        requestStore.updateStatus(message.requestId(), "PROCESSING", null, totalIndexed);
      }

      requestStore.updateStatus(message.requestId(), "COMPLETED", null, totalIndexed);
      LOG.info("Completed indexing request {} with {} games", message.requestId(), totalIndexed);
    } catch (Exception e) {
      LOG.error("Failed to process index request {}", message.requestId(), e);
      requestStore.updateStatus(message.requestId(), "FAILED", e.getMessage(), 0);
    }
  }

  private void indexGame(IndexMessage message, PlayedGame game) {
    GameFeatures features = featureExtractor.extract(game.pgn());

    String result = determineResult(game);

    GameFeature row =
        new GameFeature(
            null, // id generated by DB
            message.requestId(),
            game.url(),
            message.platform(),
            game.whiteResult() != null ? game.whiteResult().username() : null,
            game.blackResult() != null ? game.blackResult().username() : null,
            game.whiteResult() != null ? Integer.valueOf(game.whiteResult().rating()) : null,
            game.blackResult() != null ? Integer.valueOf(game.blackResult().rating()) : null,
            game.timeClass(),
            extractEcoFromPgn(game.pgn()),
            result,
            game.endTime(),
            features.numMoves(),
            Instant.now(),
            game.pgn());

    gameFeatureStore.insert(row);
    gameFeatureStore.insertOccurrences(game.url(), features.occurrences());
  }

  private String determineResult(PlayedGame game) {
    String whiteResult = game.whiteResult() != null ? game.whiteResult().result() : null;
    String blackResult = game.blackResult() != null ? game.blackResult().result() : null;
    return ResultMapper.mapResult(whiteResult, blackResult);
  }

  private String extractEcoFromPgn(String pgn) {
    Matcher m = ECO_PATTERN.matcher(pgn);
    return m.find() ? m.group(1) : null;
  }
}
