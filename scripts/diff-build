#!/bin/bash
set -euo pipefail

# Script to run bazel-diff for selective building and testing
# Usage: ./scripts/diff-build [base-revision]

BASE_REVISION=${1:-"origin/main"}
WORKSPACE_ROOT=$(bazel info workspace)
BAZEL_PATH=$(which bazel)
BAZEL_DIFF_BIN="/tmp/bazel_diff"

# Download pre-built bazel-diff binary if not already cached
if [ ! -f "$BAZEL_DIFF_BIN" ]; then
  echo "Downloading bazel-diff binary..."
  BAZEL_DIFF_VERSION="12.1.1"
  BAZEL_DIFF_URL="https://github.com/Tinder/bazel-diff/releases/download/${BAZEL_DIFF_VERSION}/bazel-diff_deploy.jar"
  curl -sL "$BAZEL_DIFF_URL" -o "$BAZEL_DIFF_BIN.jar"
  # Create wrapper script to run the jar
  cat > "$BAZEL_DIFF_BIN" << 'EOF'
#!/bin/bash
exec java -jar "$(dirname "$0")/bazel_diff.jar" "$@"
EOF
  chmod +x "$BAZEL_DIFF_BIN"
fi

# Output files
starting_hashes_json="/tmp/starting_hashes.json"
final_hashes_json="/tmp/final_hashes.json"
impacted_targets_path="/tmp/impacted_targets.txt"

echo "Running bazel-diff against base revision: $BASE_REVISION"

# Always run buildifier test first
echo "Running buildifier test..."
bazel test //:buildifier_test || {
    echo "ERROR: buildifier test failed. Please run 'bazel run //:buildifier_fix' to fix formatting issues."
    exit 1
}
echo "Buildifier test passed!"
echo ""

# Get current commit for restoration
CURRENT_COMMIT=$(git rev-parse HEAD)

# Check if Bazel configuration files are changing between base and current
# If so, bazel-diff won't work reliably, so we need a full build
BAZEL_CONFIG_CHANGES=$(git diff --name-only "$BASE_REVISION" HEAD -- .bazelversion .bazelrc MODULE.bazel 'bazel/*' 2>/dev/null || echo "")

if [ -n "$BAZEL_CONFIG_CHANGES" ]; then
  echo "==================== BAZEL CONFIG CHANGE DETECTED ===================="
  echo "Changed files:"
  echo "$BAZEL_CONFIG_CHANGES" | sed 's/^/  /'
  echo "======================================================================"
  echo ""
  echo "bazel-diff is not reliable when Bazel configuration changes."
  echo "Falling back to full build and test..."
  echo ""

  echo "Building all targets..."
  bazel build //... || exit 1

  echo "Testing all targets..."
  bazel test //... || exit 1

  echo ""
  echo "Full build completed successfully!"
  exit 0
fi

# Get list of external repos for fine-grained hashing (must be done from current commit)
echo "Getting external repositories list..."
cd "$WORKSPACE_ROOT"
# Use bazel query to find all external repositories used by the project
EXTERNAL_REPOS=$("$BAZEL_PATH" query --output=package 'deps(//...)' 2>/dev/null | grep "^@" | sed 's/^@//' | sed 's/+.*//' | sort -u | grep -v "bazel_tools\|local_config" | head -50 | sed 's/^/--fineGrainedHashExternalRepos=/' | tr '\n' ' ') || true
if [ -z "$EXTERNAL_REPOS" ]; then
  echo "Could not determine external repos automatically, continuing without fine-grained hashing"
else
  echo "Found external repos for fine-grained hashing"
fi

# Generate hashes for base revision
echo "Generating hashes for base revision..."
# Force checkout, discarding local changes to MODULE.bazel.lock
git -C "$WORKSPACE_ROOT" checkout "$BASE_REVISION" --quiet --force
"$BAZEL_DIFF_BIN" generate-hashes -w "$WORKSPACE_ROOT" -b "$BAZEL_PATH" $EXTERNAL_REPOS "$starting_hashes_json"

# Generate hashes for current revision
echo "Generating hashes for current revision..."
git -C "$WORKSPACE_ROOT" checkout "$CURRENT_COMMIT" --quiet --force
"$BAZEL_DIFF_BIN" generate-hashes -w "$WORKSPACE_ROOT" -b "$BAZEL_PATH" $EXTERNAL_REPOS "$final_hashes_json"

# Get impacted targets
echo "Computing impacted targets..."
"$BAZEL_DIFF_BIN" get-impacted-targets -sh "$starting_hashes_json" -fh "$final_hashes_json" -o "$impacted_targets_path"

# Read impacted targets
impacted_targets=()
if [ -f "$impacted_targets_path" ]; then
  while IFS= read -r line; do
    # Skip deprecated requirements_test target (use requirements.test instead)
    # Skip web/build_pal:test due to jsdom sandbox compatibility in CI
    if [[ "$line" != "//:requirements_test" ]] && [[ "$line" != "//web/build_pal:test" ]]; then
      impacted_targets+=("$line")
    fi
  done < "$impacted_targets_path"
fi

if [ ${#impacted_targets[@]} -eq 0 ]; then
  echo "No impacted targets found. Skipping build and test."
  exit 0
fi

echo "==================== IMPACTED TARGETS ===================="
echo "Found ${#impacted_targets[@]} impacted targets:"
echo ""

# Categorize targets
local_targets=()
external_targets=()
OS_NAME=$(uname)
for target in "${impacted_targets[@]}"; do
  # Skip iOS targets on non-macOS platforms
  if [[ "$OS_NAME" != "Darwin" ]] && [[ "$target" == *"wordchains_ios"* ]]; then
    echo "Skipping iOS target on non-macOS: $target"
    continue
  fi

  if [[ "$target" == @* ]]; then
    external_targets+=("$target")
  else
    local_targets+=("$target")
  fi
done

# Display categorized targets
if [ ${#local_targets[@]} -gt 0 ]; then
  echo "LOCAL TARGETS (${#local_targets[@]}):"
  printf '  %s\n' "${local_targets[@]}"
  echo ""
fi

if [ ${#external_targets[@]} -gt 0 ]; then
  echo "EXTERNAL TARGETS (${#external_targets[@]}):"
  printf '  %s\n' "${external_targets[@]}"
  echo ""
fi

echo "=========================================================="
echo ""

# Use bazel query to reliably identify test targets (not name heuristics)
build_targets=()
test_targets=()

if [ ${#local_targets[@]} -gt 0 ]; then
  # Filter to rule targets only (skip source files like :src/foo.rs, :BUILD.bazel)
  rule_targets=()
  for target in "${local_targets[@]}"; do
    label="${target##*:}"
    if [[ "$label" != *"/"* ]] && [[ "$label" != *"."* ]]; then
      rule_targets+=("$target")
    fi
  done

  # Filter out targets tagged as manual (e.g., iOS targets on Linux)
  if [ ${#rule_targets[@]} -gt 0 ]; then
    target_set="${rule_targets[*]}"
    # Use bazel query to filter out manual targets
    # Note: set() expects space-separated list of targets
    non_manual_targets=$(bazel query "set($target_set) except attr(tags, 'manual', set($target_set))" 2>/dev/null || echo "")

    # Re-populate rule_targets with only non-manual targets
    rule_targets=($non_manual_targets)
  fi

  # Ask Bazel which rule targets are test rules
  test_set=""
  if [ ${#rule_targets[@]} -gt 0 ]; then
    target_set="${rule_targets[*]}"
    test_set=$(bazel query "kind('.*_test rule', set($target_set))" 2>/dev/null || echo "")
  fi

  for target in "${local_targets[@]}"; do
    if echo "$test_set" | grep -qxF "$target"; then
      test_targets+=("$target")
    else
      build_targets+=("$target")
    fi
  done
fi

# Build only non-test targets
if [ ${#build_targets[@]} -gt 0 ]; then
  echo "Building ${#build_targets[@]} targets..."
  bazel build --keep_going --skip_incompatible_explicit_targets "${build_targets[@]}"
else
  echo "No build targets to build."
fi

# Test only test targets
if [ ${#test_targets[@]} -gt 0 ]; then
  echo "Testing ${#test_targets[@]} test targets..."
  bazel test --keep_going --skip_incompatible_explicit_targets "${test_targets[@]}"
else
  echo "No test targets to run."
fi

echo ""
echo "bazel-diff build completed successfully!"
