package com.moonbase.smithy.go;

import com.moonbase.smithy.codegen.CodeGenerator;
import com.moonbase.smithy.codegen.CodeWriter;
import com.moonbase.smithy.codegen.NameUtils;
import com.moonbase.smithy.model.*;
import com.moonbase.smithy.model.Shape.ShapeType;

import java.io.IOException;
import java.nio.file.Path;
import java.util.Optional;

/**
 * Generates Go server code from Smithy models.
 */
public class GoServerGenerator implements CodeGenerator {

    @Override
    public String getLanguage() {
        return "go";
    }

    @Override
    public void generate(SmithyModel model, Path outputDir, GeneratorOptions options) throws IOException {
        String moduleName = options.getModuleName() != null
            ? options.getModuleName()
            : NameUtils.toSnakeCase(model.getNamespace().replace(".", "_"));

        // Generate types.go
        generateTypes(model, moduleName, outputDir);

        // Generate service interfaces
        for (Service service : model.getServices().values()) {
            generateService(service, model, moduleName, outputDir);
            generateHandler(service, model, moduleName, outputDir);
        }

        // Generate errors
        generateErrors(model, moduleName, outputDir);

        // Generate go.mod placeholder
        generateGoMod(moduleName, outputDir);
    }

    private void generateTypes(SmithyModel model, String moduleName, Path outputDir) throws IOException {
        CodeWriter writer = new CodeWriter("\t");

        writer.writeLine("// Code generated by smithy-go-generator. DO NOT EDIT.");
        writer.newLine();
        writer.writeLine("package %s", moduleName);
        writer.newLine();
        writer.writeLine("import (");
        writer.indent();
        writer.writeLine("\"encoding/json\"");
        writer.writeLine("\"time\"");
        writer.dedent();
        writer.writeLine(")");
        writer.newLine();
        writer.writeLine("// Suppress unused import warnings");
        writer.writeLine("var _ = json.Marshal");
        writer.writeLine("var _ = time.Now");
        writer.newLine();

        for (Shape shape : model.getShapes().values()) {
            if (shape.hasTrait(Trait.ERROR)) {
                continue; // Errors are generated separately
            }

            if (shape.getType() == ShapeType.STRUCTURE) {
                generateStruct(writer, shape, model);
            } else if (shape.getType() == ShapeType.ENUM) {
                generateEnum(writer, shape);
            } else if (shape.getType() == ShapeType.UNION) {
                generateUnion(writer, shape, model);
            }
        }

        writer.writeToFile(outputDir.resolve("types.go"));
    }

    private void generateStruct(CodeWriter writer, Shape shape, SmithyModel model) {
        String structName = NameUtils.toPascalCase(shape.getName());

        shape.getTrait(Trait.DOCUMENTATION).ifPresent(doc ->
            writer.writeDocComment(doc.getStringValue(), "//"));

        writer.writeLine("type %s struct {", structName);
        writer.indent();

        for (Member member : shape.getMembers()) {
            String fieldName = NameUtils.toPascalCase(member.getName());
            String fieldType = mapToGoType(member.getTarget(), model, member.isOptional());
            String jsonTag = NameUtils.toCamelCase(member.getName());
            String omitEmpty = member.isOptional() ? ",omitempty" : "";

            member.getDocumentation().ifPresent(doc ->
                writer.writeDocComment(doc, "//"));
            writer.writeLine("%s %s `json:\"%s%s\"`", fieldName, fieldType, jsonTag, omitEmpty);
        }

        writer.dedent();
        writer.writeLine("}");
        writer.newLine();
    }

    private void generateEnum(CodeWriter writer, Shape shape) {
        String typeName = NameUtils.toPascalCase(shape.getName());

        shape.getTrait(Trait.DOCUMENTATION).ifPresent(doc ->
            writer.writeDocComment(doc.getStringValue(), "//"));

        writer.writeLine("type %s string", typeName);
        writer.newLine();
        writer.writeLine("const (");
        writer.indent();

        for (Member member : shape.getMembers()) {
            String constName = typeName + NameUtils.toPascalCase(member.getName());
            writer.writeLine("%s %s = \"%s\"", constName, typeName, member.getName());
        }

        writer.dedent();
        writer.writeLine(")");
        writer.newLine();

        // Values function
        writer.writeLine("func (%s) Values() []%s {", typeName, typeName);
        writer.indent();
        writer.write("return []%s{", typeName);
        boolean first = true;
        for (Member member : shape.getMembers()) {
            if (!first) writer.write(", ");
            first = false;
            writer.write("%s%s", typeName, NameUtils.toPascalCase(member.getName()));
        }
        writer.writeLine("}");
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();
    }

    private void generateUnion(CodeWriter writer, Shape shape, SmithyModel model) {
        String typeName = NameUtils.toPascalCase(shape.getName());

        shape.getTrait(Trait.DOCUMENTATION).ifPresent(doc ->
            writer.writeDocComment(doc.getStringValue(), "//"));

        // Interface type
        writer.writeLine("type %s interface {", typeName);
        writer.indent();
        writer.writeLine("is%s()", typeName);
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();

        // Variant types
        for (Member member : shape.getMembers()) {
            String variantName = typeName + NameUtils.toPascalCase(member.getName());
            String valueType = mapToGoType(member.getTarget(), model, false);

            writer.writeLine("type %s struct {", variantName);
            writer.indent();
            writer.writeLine("Value %s", valueType);
            writer.dedent();
            writer.writeLine("}");
            writer.newLine();
            writer.writeLine("func (%s) is%s() {}", variantName, typeName);
            writer.newLine();
        }
    }

    private void generateService(Service service, SmithyModel model, String moduleName, Path outputDir) throws IOException {
        CodeWriter writer = new CodeWriter("\t");
        String serviceName = NameUtils.toPascalCase(service.getName());

        writer.writeLine("// Code generated by smithy-go-generator. DO NOT EDIT.");
        writer.newLine();
        writer.writeLine("package %s", moduleName);
        writer.newLine();
        writer.writeLine("import \"context\"");
        writer.newLine();

        service.getTrait(Trait.DOCUMENTATION).ifPresent(doc ->
            writer.writeDocComment(doc.getStringValue(), "//"));

        writer.writeLine("type %s interface {", serviceName);
        writer.indent();

        for (Operation op : service.getOperations()) {
            String methodName = NameUtils.toPascalCase(op.getName());
            String inputType = op.getInput() != null
                ? "*" + NameUtils.toPascalCase(NameUtils.getSimpleName(op.getInput()))
                : "struct{}";
            String outputType = op.getOutput() != null
                ? "*" + NameUtils.toPascalCase(NameUtils.getSimpleName(op.getOutput()))
                : "struct{}";

            op.getDocumentation().ifPresent(doc ->
                writer.writeDocComment(doc, "//"));
            writer.writeLine("%s(ctx context.Context, input %s) (%s, error)", methodName, inputType, outputType);
        }

        writer.dedent();
        writer.writeLine("}");

        String fileName = NameUtils.toSnakeCase(serviceName) + ".go";
        writer.writeToFile(outputDir.resolve(fileName));
    }

    private void generateHandler(Service service, SmithyModel model, String moduleName, Path outputDir) throws IOException {
        CodeWriter writer = new CodeWriter("\t");
        String serviceName = NameUtils.toPascalCase(service.getName());
        String handlerName = serviceName + "Handler";

        writer.writeLine("// Code generated by smithy-go-generator. DO NOT EDIT.");
        writer.newLine();
        writer.writeLine("package %s", moduleName);
        writer.newLine();
        writer.writeLine("import (");
        writer.indent();
        writer.writeLine("\"context\"");
        writer.writeLine("\"encoding/json\"");
        writer.writeLine("\"net/http\"");
        writer.writeLine("\"regexp\"");
        writer.dedent();
        writer.writeLine(")");
        writer.newLine();

        // Handler struct
        writer.writeDocComment(handlerName + " provides HTTP routing for " + serviceName, "//");
        writer.writeLine("type %s struct {", handlerName);
        writer.indent();
        writer.writeLine("service %s", serviceName);
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();

        // Constructor
        writer.writeLine("func New%s(service %s) *%s {", handlerName, serviceName, handlerName);
        writer.indent();
        writer.writeLine("return &%s{service: service}", handlerName);
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();

        // Route patterns
        for (Operation op : service.getOperations()) {
            String patternName = NameUtils.toCamelCase(op.getName()) + "Pattern";
            String uri = op.getHttpUri();
            String pattern = "^" + uri.replaceAll("\\{([^}]+)\\}", "(?P<$1>[^/]+)") + "$";
            writer.writeLine("var %s = regexp.MustCompile(`%s`)", patternName, pattern);
        }
        writer.newLine();

        // ServeHTTP method
        writer.writeLine("func (h *%s) ServeHTTP(w http.ResponseWriter, r *http.Request) {", handlerName);
        writer.indent();
        writer.writeLine("ctx := r.Context()");
        writer.writeLine("path := r.URL.Path");
        writer.writeLine("method := r.Method");
        writer.newLine();

        for (Operation op : service.getOperations()) {
            String methodName = NameUtils.toPascalCase(op.getName());
            String patternName = NameUtils.toCamelCase(op.getName()) + "Pattern";
            String httpMethod = op.getHttpMethod();
            String inputType = op.getInput() != null
                ? NameUtils.toPascalCase(NameUtils.getSimpleName(op.getInput()))
                : "";

            writer.writeLine("if method == \"%s\" && %s.MatchString(path) {", httpMethod, patternName);
            writer.indent();
            writer.writeLine("h.handle%s(ctx, w, r)", methodName);
            writer.writeLine("return");
            writer.dedent();
            writer.writeLine("}");
            writer.newLine();
        }

        writer.writeLine("http.NotFound(w, r)");
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();

        // Individual operation handlers
        for (Operation op : service.getOperations()) {
            String methodName = NameUtils.toPascalCase(op.getName());
            String inputType = op.getInput() != null
                ? NameUtils.toPascalCase(NameUtils.getSimpleName(op.getInput()))
                : "";
            int successCode = op.getHttpCode();

            writer.writeLine("func (h *%s) handle%s(ctx context.Context, w http.ResponseWriter, r *http.Request) {",
                handlerName, methodName);
            writer.indent();

            if (!inputType.isEmpty()) {
                writer.writeLine("var input %s", inputType);
                writer.writeLine("if err := json.NewDecoder(r.Body).Decode(&input); err != nil {");
                writer.indent();
                writer.writeLine("http.Error(w, err.Error(), http.StatusBadRequest)");
                writer.writeLine("return");
                writer.dedent();
                writer.writeLine("}");
                writer.newLine();
                writer.writeLine("output, err := h.service.%s(ctx, &input)", methodName);
            } else {
                writer.writeLine("output, err := h.service.%s(ctx, struct{}{})", methodName);
            }

            writer.writeLine("if err != nil {");
            writer.indent();
            writer.writeLine("handleError(w, err)");
            writer.writeLine("return");
            writer.dedent();
            writer.writeLine("}");
            writer.newLine();

            writer.writeLine("w.Header().Set(\"Content-Type\", \"application/json\")");
            writer.writeLine("w.WriteHeader(%d)", successCode);
            writer.writeLine("json.NewEncoder(w).Encode(output)");
            writer.dedent();
            writer.writeLine("}");
            writer.newLine();
        }

        // Error handler helper
        writer.writeLine("func handleError(w http.ResponseWriter, err error) {");
        writer.indent();
        writer.writeLine("if apiErr, ok := err.(APIError); ok {");
        writer.indent();
        writer.writeLine("w.Header().Set(\"Content-Type\", \"application/json\")");
        writer.writeLine("w.WriteHeader(apiErr.HTTPStatusCode())");
        writer.writeLine("json.NewEncoder(w).Encode(map[string]string{\"error\": apiErr.Error()})");
        writer.writeLine("return");
        writer.dedent();
        writer.writeLine("}");
        writer.writeLine("http.Error(w, err.Error(), http.StatusInternalServerError)");
        writer.dedent();
        writer.writeLine("}");

        String fileName = NameUtils.toSnakeCase(serviceName) + "_handler.go";
        writer.writeToFile(outputDir.resolve(fileName));
    }

    private void generateErrors(SmithyModel model, String moduleName, Path outputDir) throws IOException {
        CodeWriter writer = new CodeWriter("\t");

        writer.writeLine("// Code generated by smithy-go-generator. DO NOT EDIT.");
        writer.newLine();
        writer.writeLine("package %s", moduleName);
        writer.newLine();

        // Base error interface
        writer.writeLine("// APIError is implemented by all service errors");
        writer.writeLine("type APIError interface {");
        writer.indent();
        writer.writeLine("error");
        writer.writeLine("HTTPStatusCode() int");
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();

        for (Shape shape : model.getShapes().values()) {
            if (shape.hasTrait(Trait.ERROR)) {
                String errorName = NameUtils.toPascalCase(shape.getName());

                String errorType = shape.getTrait(Trait.ERROR)
                    .map(Trait::getStringValue)
                    .orElse("server");
                int statusCode = shape.getTrait(Trait.HTTP_ERROR)
                    .flatMap(Trait::getNumberValue)
                    .map(Number::intValue)
                    .orElse(errorType.equals("client") ? 400 : 500);

                shape.getTrait(Trait.DOCUMENTATION).ifPresent(doc ->
                    writer.writeDocComment(doc.getStringValue(), "//"));

                writer.writeLine("type %s struct {", errorName);
                writer.indent();
                writer.writeLine("Message string `json:\"message\"`");
                for (Member member : shape.getMembers()) {
                    if (!member.getName().equals("message")) {
                        String fieldName = NameUtils.toPascalCase(member.getName());
                        String fieldType = mapToGoType(member.getTarget(), model, member.isOptional());
                        writer.writeLine("%s %s `json:\"%s\"`", fieldName, fieldType,
                            NameUtils.toCamelCase(member.getName()));
                    }
                }
                writer.dedent();
                writer.writeLine("}");
                writer.newLine();

                writer.writeLine("func (e *%s) Error() string {", errorName);
                writer.indent();
                writer.writeLine("return e.Message");
                writer.dedent();
                writer.writeLine("}");
                writer.newLine();

                writer.writeLine("func (e *%s) HTTPStatusCode() int {", errorName);
                writer.indent();
                writer.writeLine("return %d", statusCode);
                writer.dedent();
                writer.writeLine("}");
                writer.newLine();
            }
        }

        writer.writeToFile(outputDir.resolve("errors.go"));
    }

    private void generateGoMod(String moduleName, Path outputDir) throws IOException {
        CodeWriter writer = new CodeWriter();
        writer.writeLine("module %s", moduleName);
        writer.newLine();
        writer.writeLine("go 1.21");
        writer.writeToFile(outputDir.resolve("go.mod"));
    }

    private String mapToGoType(String smithyType, SmithyModel model, boolean optional) {
        if (smithyType == null) return "struct{}"

        String simpleName = NameUtils.getSimpleName(smithyType);
        String baseType = switch (smithyType) {
            case "smithy.api#Blob" -> "[]byte";
            case "smithy.api#Boolean" -> "bool";
            case "smithy.api#String" -> "string";
            case "smithy.api#Byte" -> "int8";
            case "smithy.api#Short" -> "int16";
            case "smithy.api#Integer" -> "int32";
            case "smithy.api#Long" -> "int64";
            case "smithy.api#Float" -> "float32";
            case "smithy.api#Double" -> "float64";
            case "smithy.api#BigInteger" -> "*big.Int";
            case "smithy.api#BigDecimal" -> "*big.Float";
            case "smithy.api#Timestamp" -> "time.Time";
            case "smithy.api#Document" -> "interface{}";
            default -> {
                Optional<Shape> shape = model.getShape(simpleName);
                if (shape.isPresent()) {
                    Shape s = shape.get();
                    if (s.getType() == ShapeType.LIST || s.getType() == ShapeType.SET) {
                        yield "[]" + mapToGoType(s.getTargetShape(), model, false);
                    } else if (s.getType() == ShapeType.MAP) {
                        yield "map[" + mapToGoType(s.getKeyShape(), model, false) + "]" +
                            mapToGoType(s.getTargetShape(), model, false);
                    }
                }
                yield NameUtils.toPascalCase(simpleName);
            }
        };

        if (optional && !baseType.startsWith("*") && !baseType.startsWith("[]") && !baseType.startsWith("map[")) {
            return "*" + baseType;
        }
        return baseType;
    }

    public static void main(String[] args) throws Exception {
        if (args.length < 2) {
            System.err.println("Usage: GoServerGenerator <model.json> <output-dir> [module-name]");
            System.exit(1);
        }

        var parser = new com.moonbase.smithy.parser.SmithyParser();
        var model = parser.parse(java.nio.file.Path.of(args[0]));
        var options = new GeneratorOptions();

        if (args.length > 2) {
            options.setModuleName(args[2]);
        }

        new GoServerGenerator().generate(model, java.nio.file.Path.of(args[1]), options);
        System.out.println("Generated Go server code in " + args[1]);
    }
}
