package com.moonbase.smithy.cpp;

import com.moonbase.smithy.codegen.CodeGenerator;
import com.moonbase.smithy.codegen.CodeWriter;
import com.moonbase.smithy.codegen.NameUtils;
import com.moonbase.smithy.model.*;
import com.moonbase.smithy.model.Shape.ShapeType;

import java.io.IOException;
import java.nio.file.Path;
import java.util.Optional;

/**
 * Generates C++ server code from Smithy models.
 */
public class CppServerGenerator implements CodeGenerator {

    @Override
    public String getLanguage() {
        return "cpp";
    }

    @Override
    public void generate(SmithyModel model, Path outputDir, GeneratorOptions options) throws IOException {
        String moduleName = options.getModuleName() != null
            ? options.getModuleName()
            : NameUtils.toSnakeCase(model.getNamespace().replace(".", "_"));

        String namespace = moduleName.replace("-", "_");

        Path includeDir = outputDir.resolve("include").resolve(moduleName);
        Path srcDir = outputDir.resolve("src");

        // Generate types header and source
        generateTypesHeader(model, namespace, includeDir);
        generateTypesSource(model, namespace, moduleName, srcDir);

        // Generate error types
        generateErrorHeader(model, namespace, includeDir);
        generateErrorSource(model, namespace, moduleName, srcDir);

        // Generate service interface and handler
        for (Service service : model.getServices().values()) {
            generateServiceHeader(service, model, namespace, includeDir);
            if (service.isWebSocket()) {
                generateWebSocketHandlerHeader(service, model, namespace, includeDir);
                generateWebSocketHandlerSource(service, model, namespace, moduleName, srcDir);
            } else {
                generateHandlerHeader(service, model, namespace, includeDir);
                generateHandlerSource(service, model, namespace, moduleName, srcDir);
            }
        }

        // Generate CMakeLists.txt
        generateCMakeLists(moduleName, model, outputDir);

        // Generate BUILD.bazel
        generateBazelBuild(moduleName, model, outputDir);
    }

    private void generateTypesHeader(SmithyModel model, String namespace, Path includeDir) throws IOException {
        CodeWriter writer = new CodeWriter();

        writer.writeLine("// Code generated by smithy-cpp-generator. DO NOT EDIT.");
        writer.writeLine("#pragma once");
        writer.newLine();
        writer.writeLine("#include <cstdint>");
        writer.writeLine("#include <memory>");
        writer.writeLine("#include <optional>");
        writer.writeLine("#include <string>");
        writer.writeLine("#include <vector>");
        writer.writeLine("#include <unordered_map>");
        writer.writeLine("#include <nlohmann/json.hpp>");
        writer.newLine();
        writer.writeLine("namespace %s {", namespace);
        writer.newLine();

        // Forward declarations
        for (Shape shape : model.getShapes().values()) {
            if (!shape.hasTrait(Trait.ERROR) &&
                (shape.getType() == ShapeType.STRUCTURE || shape.getType() == ShapeType.UNION)) {
                writer.writeLine("struct %s;", NameUtils.toPascalCase(shape.getName()));
            }
        }
        writer.newLine();

        // Enums
        for (Shape shape : model.getShapes().values()) {
            if (shape.getType() == ShapeType.ENUM) {
                generateEnumHeader(writer, shape);
            }
        }

        // Structures
        for (Shape shape : model.getShapes().values()) {
            if (!shape.hasTrait(Trait.ERROR) && shape.getType() == ShapeType.STRUCTURE) {
                generateStructHeader(writer, shape, model);
            }
        }

        // Unions
        for (Shape shape : model.getShapes().values()) {
            if (shape.getType() == ShapeType.UNION) {
                generateUnionHeader(writer, shape, model);
            }
        }

        writer.writeLine("} // namespace %s", namespace);

        writer.writeToFile(includeDir.resolve("types.h"));
    }

    private void generateStructHeader(CodeWriter writer, Shape shape, SmithyModel model) {
        String structName = NameUtils.toPascalCase(shape.getName());

        shape.getTrait(Trait.DOCUMENTATION).ifPresent(doc -> {
            writer.writeLine("/**");
            writer.writeLine(" * %s", doc.getStringValue().replace("\n", "\n * "));
            writer.writeLine(" */");
        });

        writer.writeLine("struct %s {", structName);
        writer.indent();

        // Fields
        for (Member member : shape.getMembers()) {
            String fieldName = NameUtils.escapeCppKeyword(NameUtils.toSnakeCase(member.getName()));
            String fieldType = mapToCppType(member.getTarget(), model);

            member.getDocumentation().ifPresent(doc ->
                writer.writeLine("/// %s", doc.replace("\n", " ")));

            if (member.isOptional()) {
                writer.writeLine("std::optional<%s> %s;", fieldType, fieldName);
            } else {
                writer.writeLine("%s %s;", fieldType, fieldName);
            }
        }

        writer.newLine();

        // Builder nested class
        writer.writeLine("class Builder {");
        writer.writeLine("public:");
        writer.indent();

        for (Member member : shape.getMembers()) {
            String fieldName = NameUtils.escapeCppKeyword(NameUtils.toSnakeCase(member.getName()));
            String fieldType = mapToCppType(member.getTarget(), model);
            String setterName = NameUtils.toPascalCase(member.getName());
            writer.writeLine("Builder& Set%s(%s value);", setterName, fieldType);
        }
        writer.writeLine("%s Build();", structName);

        writer.dedent();
        writer.writeLine("private:");
        writer.indent();
        writer.writeLine("%s result_;", structName);
        writer.dedent();
        writer.writeLine("};");
        writer.newLine();

        writer.writeLine("static Builder builder() { return Builder(); }");

        writer.dedent();
        writer.writeLine("};");
        writer.newLine();

        // JSON serialization declarations
        writer.writeLine("void to_json(nlohmann::json& j, const %s& v);", structName);
        writer.writeLine("void from_json(const nlohmann::json& j, %s& v);", structName);
        writer.newLine();
    }

    private void generateEnumHeader(CodeWriter writer, Shape shape) {
        String enumName = NameUtils.toPascalCase(shape.getName());

        shape.getTrait(Trait.DOCUMENTATION).ifPresent(doc -> {
            writer.writeLine("/**");
            writer.writeLine(" * %s", doc.getStringValue().replace("\n", "\n * "));
            writer.writeLine(" */");
        });

        writer.writeLine("enum class %s {", enumName);
        writer.indent();

        for (Member member : shape.getMembers()) {
            String valueName = NameUtils.toPascalCase(member.getName());
            writer.writeLine("%s,", valueName);
        }

        writer.dedent();
        writer.writeLine("};");
        writer.newLine();

        writer.writeLine("std::string ToString(%s value);", enumName);
        writer.writeLine("%s %sFromString(const std::string& str);", enumName, enumName);
        writer.writeLine("void to_json(nlohmann::json& j, const %s& v);", enumName);
        writer.writeLine("void from_json(const nlohmann::json& j, %s& v);", enumName);
        writer.newLine();
    }

    private void generateUnionHeader(CodeWriter writer, Shape shape, SmithyModel model) {
        String unionName = NameUtils.toPascalCase(shape.getName());

        shape.getTrait(Trait.DOCUMENTATION).ifPresent(doc -> {
            writer.writeLine("/**");
            writer.writeLine(" * %s", doc.getStringValue().replace("\n", "\n * "));
            writer.writeLine(" */");
        });

        writer.writeLine("struct %s {", unionName);
        writer.indent();

        writer.writeLine("enum class Type {");
        writer.indent();
        writer.writeLine("kUnknown,");
        for (Member member : shape.getMembers()) {
            writer.writeLine("k%s,", NameUtils.toPascalCase(member.getName()));
        }
        writer.dedent();
        writer.writeLine("};");
        writer.newLine();

        writer.writeLine("Type type = Type::kUnknown;");
        writer.writeLine("std::variant<std::monostate");
        for (Member member : shape.getMembers()) {
            String valueType = mapToCppType(member.getTarget(), model);
            writer.writeLine("    , %s", valueType);
        }
        writer.writeLine("> value;");
        writer.newLine();

        // Factory methods
        for (Member member : shape.getMembers()) {
            String methodName = NameUtils.toPascalCase(member.getName());
            String valueType = mapToCppType(member.getTarget(), model);
            writer.writeLine("static %s %s(%s value);", unionName, methodName, valueType);
        }

        // Getters
        writer.newLine();
        for (Member member : shape.getMembers()) {
            String methodName = NameUtils.toPascalCase(member.getName());
            String valueType = mapToCppType(member.getTarget(), model);
            writer.writeLine("const %s& As%s() const;", valueType, methodName);
            writer.writeLine("bool Is%s() const;", methodName);
        }

        writer.dedent();
        writer.writeLine("};");
        writer.newLine();

        writer.writeLine("void to_json(nlohmann::json& j, const %s& v);", unionName);
        writer.writeLine("void from_json(const nlohmann::json& j, %s& v);", unionName);
        writer.newLine();
    }

    private void generateTypesSource(SmithyModel model, String namespace, String moduleName, Path srcDir) throws IOException {
        CodeWriter writer = new CodeWriter();

        writer.writeLine("// Code generated by smithy-cpp-generator. DO NOT EDIT.");
        writer.newLine();
        writer.writeLine("#include \"%s/types.h\"", moduleName);
        writer.newLine();
        writer.writeLine("namespace %s {", namespace);
        writer.newLine();

        // Enum implementations
        for (Shape shape : model.getShapes().values()) {
            if (shape.getType() == ShapeType.ENUM) {
                generateEnumSource(writer, shape);
            }
        }

        // Structure implementations
        for (Shape shape : model.getShapes().values()) {
            if (!shape.hasTrait(Trait.ERROR) && shape.getType() == ShapeType.STRUCTURE) {
                generateStructSource(writer, shape, model);
            }
        }

        // Union implementations
        for (Shape shape : model.getShapes().values()) {
            if (shape.getType() == ShapeType.UNION) {
                generateUnionSource(writer, shape, model);
            }
        }

        writer.writeLine("} // namespace %s", namespace);

        writer.writeToFile(srcDir.resolve("types.cc"));
    }

    private void generateStructSource(CodeWriter writer, Shape shape, SmithyModel model) {
        String structName = NameUtils.toPascalCase(shape.getName());

        // Builder methods
        for (Member member : shape.getMembers()) {
            String fieldName = NameUtils.escapeCppKeyword(NameUtils.toSnakeCase(member.getName()));
            String fieldType = mapToCppType(member.getTarget(), model);
            String setterName = NameUtils.toPascalCase(member.getName());

            writer.writeLine("%s::Builder& %s::Builder::Set%s(%s value) {",
                structName, structName, setterName, fieldType);
            writer.indent();
            writer.writeLine("result_.%s = std::move(value);", fieldName);
            writer.writeLine("return *this;");
            writer.dedent();
            writer.writeLine("}");
            writer.newLine();
        }

        writer.writeLine("%s %s::Builder::Build() {", structName, structName);
        writer.indent();
        writer.writeLine("return std::move(result_);");
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();

        // JSON serialization
        writer.writeLine("void to_json(nlohmann::json& j, const %s& v) {", structName);
        writer.indent();
        writer.writeLine("j = nlohmann::json{");
        writer.indent();
        boolean first = true;
        for (Member member : shape.getMembers()) {
            String fieldName = NameUtils.escapeCppKeyword(NameUtils.toSnakeCase(member.getName()));
            String jsonKey = NameUtils.toCamelCase(member.getName());
            if (!first) writer.writeLine(",");
            first = false;
            writer.write("{\"%s\", v.%s}", jsonKey, fieldName);
        }
        writer.newLine();
        writer.dedent();
        writer.writeLine("};");
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();

        writer.writeLine("void from_json(const nlohmann::json& j, %s& v) {", structName);
        writer.indent();
        for (Member member : shape.getMembers()) {
            String fieldName = NameUtils.escapeCppKeyword(NameUtils.toSnakeCase(member.getName()));
            String jsonKey = NameUtils.toCamelCase(member.getName());
            if (member.isOptional()) {
                writer.writeLine("if (j.contains(\"%s\")) j.at(\"%s\").get_to(v.%s);",
                    jsonKey, jsonKey, fieldName);
            } else {
                writer.writeLine("j.at(\"%s\").get_to(v.%s);", jsonKey, fieldName);
            }
        }
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();
    }

    private void generateEnumSource(CodeWriter writer, Shape shape) {
        String enumName = NameUtils.toPascalCase(shape.getName());

        // ToString
        writer.writeLine("std::string ToString(%s value) {", enumName);
        writer.indent();
        writer.writeLine("switch (value) {");
        writer.indent();
        for (Member member : shape.getMembers()) {
            String valueName = NameUtils.toPascalCase(member.getName());
            writer.writeLine("case %s::%s: return \"%s\";", enumName, valueName, member.getName());
        }
        writer.writeLine("default: return \"UNKNOWN\";");
        writer.dedent();
        writer.writeLine("}");
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();

        // FromString
        writer.writeLine("%s %sFromString(const std::string& str) {", enumName, enumName);
        writer.indent();
        for (Member member : shape.getMembers()) {
            String valueName = NameUtils.toPascalCase(member.getName());
            writer.writeLine("if (str == \"%s\") return %s::%s;", member.getName(), enumName, valueName);
        }
        writer.writeLine("throw std::invalid_argument(\"Unknown %s: \" + str);", enumName);
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();

        // JSON
        writer.writeLine("void to_json(nlohmann::json& j, const %s& v) {", enumName);
        writer.indent();
        writer.writeLine("j = ToString(v);");
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();

        writer.writeLine("void from_json(const nlohmann::json& j, %s& v) {", enumName);
        writer.indent();
        writer.writeLine("v = %sFromString(j.get<std::string>());", enumName);
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();
    }

    private void generateUnionSource(CodeWriter writer, Shape shape, SmithyModel model) {
        String unionName = NameUtils.toPascalCase(shape.getName());

        // Factory methods
        int index = 1;
        for (Member member : shape.getMembers()) {
            String methodName = NameUtils.toPascalCase(member.getName());
            String valueType = mapToCppType(member.getTarget(), model);

            writer.writeLine("%s %s::%s(%s value) {", unionName, unionName, methodName, valueType);
            writer.indent();
            writer.writeLine("%s result;", unionName);
            writer.writeLine("result.type = Type::k%s;", methodName);
            writer.writeLine("result.value = std::move(value);");
            writer.writeLine("return result;");
            writer.dedent();
            writer.writeLine("}");
            writer.newLine();
            index++;
        }

        // Getters
        index = 1;
        for (Member member : shape.getMembers()) {
            String methodName = NameUtils.toPascalCase(member.getName());
            String valueType = mapToCppType(member.getTarget(), model);

            writer.writeLine("const %s& %s::As%s() const {", valueType, unionName, methodName);
            writer.indent();
            writer.writeLine("return std::get<%d>(value);", index);
            writer.dedent();
            writer.writeLine("}");
            writer.newLine();

            writer.writeLine("bool %s::Is%s() const {", unionName, methodName);
            writer.indent();
            writer.writeLine("return type == Type::k%s;", methodName);
            writer.dedent();
            writer.writeLine("}");
            writer.newLine();
            index++;
        }

        // JSON serialization
        writer.writeLine("void to_json(nlohmann::json& j, const %s& v) {", unionName);
        writer.indent();
        writer.writeLine("switch (v.type) {");
        writer.indent();
        index = 1;
        for (Member member : shape.getMembers()) {
            String methodName = NameUtils.toPascalCase(member.getName());
            String jsonKey = NameUtils.toCamelCase(member.getName());
            writer.writeLine("case %s::Type::k%s:", unionName, methodName);
            writer.indent();
            writer.writeLine("j = nlohmann::json{{\"%s\", std::get<%d>(v.value)}};", jsonKey, index);
            writer.writeLine("break;");
            writer.dedent();
            index++;
        }
        writer.writeLine("default: break;");
        writer.dedent();
        writer.writeLine("}");
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();

        writer.writeLine("void from_json(const nlohmann::json& j, %s& v) {", unionName);
        writer.indent();
        for (Member member : shape.getMembers()) {
            String methodName = NameUtils.toPascalCase(member.getName());
            String jsonKey = NameUtils.toCamelCase(member.getName());
            String valueType = mapToCppType(member.getTarget(), model);
            writer.writeLine("if (j.contains(\"%s\")) {", jsonKey);
            writer.indent();
            writer.writeLine("v = %s::%s(j.at(\"%s\").get<%s>());", unionName, methodName, jsonKey, valueType);
            writer.writeLine("return;");
            writer.dedent();
            writer.writeLine("}");
        }
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();
    }

    private void generateErrorHeader(SmithyModel model, String namespace, Path includeDir) throws IOException {
        CodeWriter writer = new CodeWriter();

        writer.writeLine("// Code generated by smithy-cpp-generator. DO NOT EDIT.");
        writer.writeLine("#pragma once");
        writer.newLine();
        writer.writeLine("#include <exception>");
        writer.writeLine("#include <string>");
        writer.writeLine("#include <nlohmann/json.hpp>");
        writer.newLine();
        writer.writeLine("namespace %s {", namespace);
        writer.newLine();

        // Base error class
        writer.writeLine("class ServiceError : public std::exception {");
        writer.writeLine("public:");
        writer.indent();
        writer.writeLine("explicit ServiceError(std::string message) : message_(std::move(message)) {}");
        writer.writeLine("const char* what() const noexcept override { return message_.c_str(); }");
        writer.writeLine("virtual int HttpStatusCode() const = 0;");
        writer.dedent();
        writer.writeLine("protected:");
        writer.indent();
        writer.writeLine("std::string message_;");
        writer.dedent();
        writer.writeLine("};");
        writer.newLine();

        // Individual error classes
        for (Shape shape : model.getShapes().values()) {
            if (shape.hasTrait(Trait.ERROR)) {
                String errorName = NameUtils.toPascalCase(shape.getName());
                String errorType = shape.getTrait(Trait.ERROR)
                    .map(Trait::getStringValue)
                    .orElse("server");
                int statusCode = shape.getTrait(Trait.HTTP_ERROR)
                    .flatMap(Trait::getNumberValue)
                    .map(Number::intValue)
                    .orElse(errorType.equals("client") ? 400 : 500);

                shape.getTrait(Trait.DOCUMENTATION).ifPresent(doc -> {
                    writer.writeLine("/**");
                    writer.writeLine(" * %s", doc.getStringValue().replace("\n", "\n * "));
                    writer.writeLine(" */");
                });

                writer.writeLine("class %s : public ServiceError {", errorName);
                writer.writeLine("public:");
                writer.indent();
                writer.writeLine("explicit %s(std::string message) : ServiceError(std::move(message)) {}", errorName);
                writer.writeLine("int HttpStatusCode() const override { return %d; }", statusCode);
                writer.dedent();
                writer.writeLine("};");
                writer.newLine();
            }
        }

        writer.writeLine("} // namespace %s", namespace);

        writer.writeToFile(includeDir.resolve("error.h"));
    }

    private void generateErrorSource(SmithyModel model, String namespace, String moduleName, Path srcDir) throws IOException {
        CodeWriter writer = new CodeWriter();

        writer.writeLine("// Code generated by smithy-cpp-generator. DO NOT EDIT.");
        writer.newLine();
        writer.writeLine("#include \"%s/error.h\"", moduleName);
        writer.newLine();
        writer.writeLine("namespace %s {", namespace);
        writer.writeLine("// Error implementations are header-only");
        writer.writeLine("} // namespace %s", namespace);

        writer.writeToFile(srcDir.resolve("error.cc"));
    }

    private void generateServiceHeader(Service service, SmithyModel model, String namespace, Path includeDir) throws IOException {
        CodeWriter writer = new CodeWriter();
        String serviceName = NameUtils.toPascalCase(service.getName());

        writer.writeLine("// Code generated by smithy-cpp-generator. DO NOT EDIT.");
        writer.writeLine("#pragma once");
        writer.newLine();
        writer.writeLine("#include \"types.h\"");
        writer.writeLine("#include \"error.h\"");
        writer.writeLine("#include <expected>");
        writer.writeLine("#include <memory>");
        writer.newLine();
        writer.writeLine("namespace %s {", namespace);
        writer.newLine();

        service.getTrait(Trait.DOCUMENTATION).ifPresent(doc -> {
            writer.writeLine("/**");
            writer.writeLine(" * %s", doc.getStringValue().replace("\n", "\n * "));
            writer.writeLine(" */");
        });

        writer.writeLine("class %s {", serviceName);
        writer.writeLine("public:");
        writer.indent();
        writer.writeLine("virtual ~%s() = default;", serviceName);
        writer.newLine();

        for (Operation op : service.getOperations()) {
            String methodName = NameUtils.toPascalCase(op.getName());
            String inputType = op.getInput() != null
                ? "const " + NameUtils.toPascalCase(NameUtils.getSimpleName(op.getInput())) + "&"
                : "void";
            String outputType = op.getOutput() != null
                ? NameUtils.toPascalCase(NameUtils.getSimpleName(op.getOutput()))
                : "void";

            op.getDocumentation().ifPresent(doc ->
                writer.writeLine("/// %s", doc.replace("\n", " ")));

            if (outputType.equals("void")) {
                writer.writeLine("virtual std::expected<void, std::unique_ptr<ServiceError>> %s(%s input) = 0;",
                    methodName, inputType.equals("void") ? "" : inputType + " input");
            } else {
                writer.writeLine("virtual std::expected<%s, std::unique_ptr<ServiceError>> %s(%s input) = 0;",
                    outputType, methodName, inputType.equals("void") ? "" : inputType + " input");
            }
            writer.newLine();
        }

        writer.dedent();
        writer.writeLine("};");
        writer.newLine();

        writer.writeLine("} // namespace %s", namespace);

        String fileName = NameUtils.toSnakeCase(serviceName) + ".h";
        writer.writeToFile(includeDir.resolve(fileName));
    }

    private void generateHandlerHeader(Service service, SmithyModel model, String namespace, Path includeDir) throws IOException {
        CodeWriter writer = new CodeWriter();
        String serviceName = NameUtils.toPascalCase(service.getName());
        String handlerName = serviceName + "Handler";

        writer.writeLine("// Code generated by smithy-cpp-generator. DO NOT EDIT.");
        writer.writeLine("#pragma once");
        writer.newLine();
        writer.writeLine("#include \"%s.h\"", NameUtils.toSnakeCase(serviceName));
        writer.writeLine("#include <functional>");
        writer.writeLine("#include <string>");
        writer.writeLine("#include <unordered_map>");
        writer.newLine();
        writer.writeLine("namespace %s {", namespace);
        writer.newLine();

        writer.writeLine("struct HttpRequest {");
        writer.indent();
        writer.writeLine("std::string method;");
        writer.writeLine("std::string path;");
        writer.writeLine("std::string body;");
        writer.writeLine("std::unordered_map<std::string, std::string> headers;");
        writer.writeLine("std::unordered_map<std::string, std::string> path_params;");
        writer.dedent();
        writer.writeLine("};");
        writer.newLine();

        writer.writeLine("struct HttpResponse {");
        writer.indent();
        writer.writeLine("int status_code;");
        writer.writeLine("std::string body;");
        writer.writeLine("std::unordered_map<std::string, std::string> headers;");
        writer.newLine();
        writer.writeLine("static HttpResponse Ok(std::string body);");
        writer.writeLine("static HttpResponse Error(int code, std::string message);");
        writer.writeLine("static HttpResponse NotFound();");
        writer.dedent();
        writer.writeLine("};");
        writer.newLine();

        writer.writeLine("/**");
        writer.writeLine(" * HTTP handler for %s", serviceName);
        writer.writeLine(" */");
        writer.writeLine("class %s {", handlerName);
        writer.writeLine("public:");
        writer.indent();
        writer.writeLine("explicit %s(std::shared_ptr<%s> service);", handlerName, serviceName);
        writer.newLine();
        writer.writeLine("HttpResponse Handle(const HttpRequest& request);");
        writer.dedent();
        writer.newLine();
        writer.writeLine("private:");
        writer.indent();
        writer.writeLine("std::shared_ptr<%s> service_;", serviceName);

        for (Operation op : service.getOperations()) {
            String methodName = NameUtils.toPascalCase(op.getName());
            writer.writeLine("HttpResponse Handle%s(const HttpRequest& request);", methodName);
        }

        writer.dedent();
        writer.writeLine("};");
        writer.newLine();

        writer.writeLine("} // namespace %s", namespace);

        String fileName = NameUtils.toSnakeCase(serviceName) + "_handler.h";
        writer.writeToFile(includeDir.resolve(fileName));
    }

    private void generateHandlerSource(Service service, SmithyModel model, String namespace, String moduleName, Path srcDir) throws IOException {
        CodeWriter writer = new CodeWriter();
        String serviceName = NameUtils.toPascalCase(service.getName());
        String handlerName = serviceName + "Handler";

        writer.writeLine("// Code generated by smithy-cpp-generator. DO NOT EDIT.");
        writer.newLine();
        writer.writeLine("#include \"%s/%s_handler.h\"", moduleName, NameUtils.toSnakeCase(serviceName));
        writer.writeLine("#include <regex>");
        writer.newLine();
        writer.writeLine("namespace %s {", namespace);
        writer.newLine();

        // HttpResponse helpers
        writer.writeLine("HttpResponse HttpResponse::Ok(std::string body) {");
        writer.indent();
        writer.writeLine("return HttpResponse{200, std::move(body), {{\"Content-Type\", \"application/json\"}}};");
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();

        writer.writeLine("HttpResponse HttpResponse::Error(int code, std::string message) {");
        writer.indent();
        writer.writeLine("nlohmann::json j = {{\"error\", message}};");
        writer.writeLine("return HttpResponse{code, j.dump(), {{\"Content-Type\", \"application/json\"}}};");
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();

        writer.writeLine("HttpResponse HttpResponse::NotFound() {");
        writer.indent();
        writer.writeLine("return Error(404, \"Not Found\");");
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();

        // Constructor
        writer.writeLine("%s::%s(std::shared_ptr<%s> service)", handlerName, handlerName, serviceName);
        writer.writeLine("    : service_(std::move(service)) {}");
        writer.newLine();

        // Route patterns
        for (Operation op : service.getOperations()) {
            String patternName = "k" + NameUtils.toPascalCase(op.getName()) + "Pattern";
            String uri = op.getHttpUri();
            String pattern = "^" + uri.replaceAll("\\{([^}]+)\\}", "([^/]+)") + "$";
            writer.writeLine("static const std::regex %s(\"%s\");", patternName, pattern);
        }
        writer.newLine();

        // Handle method
        writer.writeLine("HttpResponse %s::Handle(const HttpRequest& request) {", handlerName);
        writer.indent();
        writer.writeLine("std::smatch match;");
        writer.newLine();

        for (Operation op : service.getOperations()) {
            String patternName = "k" + NameUtils.toPascalCase(op.getName()) + "Pattern";
            String methodName = NameUtils.toPascalCase(op.getName());
            String httpMethod = op.getHttpMethod();

            writer.writeLine("if (request.method == \"%s\" && std::regex_match(request.path, match, %s)) {",
                httpMethod, patternName);
            writer.indent();
            writer.writeLine("return Handle%s(request);", methodName);
            writer.dedent();
            writer.writeLine("}");
            writer.newLine();
        }

        writer.writeLine("return HttpResponse::NotFound();");
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();

        // Individual handlers
        for (Operation op : service.getOperations()) {
            String methodName = NameUtils.toPascalCase(op.getName());
            String inputType = op.getInput() != null
                ? NameUtils.toPascalCase(NameUtils.getSimpleName(op.getInput()))
                : null;
            String outputType = op.getOutput() != null
                ? NameUtils.toPascalCase(NameUtils.getSimpleName(op.getOutput()))
                : null;
            int successCode = op.getHttpCode();

            writer.writeLine("HttpResponse %s::Handle%s(const HttpRequest& request) {", handlerName, methodName);
            writer.indent();

            if (inputType != null) {
                writer.writeLine("%s input;", inputType);
                writer.writeLine("try {");
                writer.indent();
                writer.writeLine("auto j = nlohmann::json::parse(request.body);");
                writer.writeLine("from_json(j, input);");
                writer.dedent();
                writer.writeLine("} catch (const std::exception& e) {");
                writer.indent();
                writer.writeLine("return HttpResponse::Error(400, e.what());");
                writer.dedent();
                writer.writeLine("}");
                writer.newLine();
                writer.writeLine("auto result = service_->%s(input);", methodName);
            } else {
                writer.writeLine("auto result = service_->%s();", methodName);
            }

            writer.writeLine("if (!result) {");
            writer.indent();
            writer.writeLine("return HttpResponse::Error(result.error()->HttpStatusCode(), result.error()->what());");
            writer.dedent();
            writer.writeLine("}");
            writer.newLine();

            if (outputType != null) {
                writer.writeLine("nlohmann::json j;");
                writer.writeLine("to_json(j, *result);");
                writer.writeLine("return HttpResponse{%d, j.dump(), {{\"Content-Type\", \"application/json\"}}};", successCode);
            } else {
                writer.writeLine("return HttpResponse{%d, \"{}\", {{\"Content-Type\", \"application/json\"}}};", successCode);
            }

            writer.dedent();
            writer.writeLine("}");
            writer.newLine();
        }

        writer.writeLine("} // namespace %s", namespace);

        String fileName = NameUtils.toSnakeCase(serviceName) + "_handler.cc";
        writer.writeToFile(srcDir.resolve(fileName));
    }

    private void generateWebSocketHandlerHeader(Service service, SmithyModel model, String namespace, Path includeDir) throws IOException {
        CodeWriter writer = new CodeWriter();
        String serviceName = NameUtils.toPascalCase(service.getName());
        String handlerName = serviceName + "WebSocketHandler";

        writer.writeLine("// Code generated by smithy-cpp-generator. DO NOT EDIT.");
        writer.writeLine("#pragma once");
        writer.newLine();
        writer.writeLine("#include \"%s.h\"", NameUtils.toSnakeCase(serviceName));
        writer.writeLine("#include <functional>");
        writer.writeLine("#include <memory>");
        writer.writeLine("#include <string>");
        writer.writeLine("#include <unordered_map>");
        writer.writeLine("#include <mutex>");
        writer.writeLine("#include <nlohmann/json.hpp>");
        writer.newLine();
        writer.writeLine("namespace %s {", namespace);
        writer.newLine();

        // WebSocketMessage struct
        writer.writeLine("struct WebSocketMessage {");
        writer.indent();
        writer.writeLine("std::string action;");
        writer.writeLine("nlohmann::json payload;");
        writer.dedent();
        writer.writeLine("};");
        writer.newLine();

        // Session struct
        writer.writeLine("class WebSocketSession {");
        writer.writeLine("public:");
        writer.indent();
        writer.writeLine("std::string id;");
        writer.writeLine("std::unordered_map<std::string, nlohmann::json> attributes;");
        writer.newLine();
        writer.writeLine("virtual ~WebSocketSession() = default;");
        writer.writeLine("virtual void Send(const WebSocketMessage& message) = 0;");
        writer.writeLine("virtual void SendText(const std::string& text) = 0;");
        writer.writeLine("virtual void Close() = 0;");
        writer.writeLine("virtual bool IsOpen() const = 0;");
        writer.dedent();
        writer.writeLine("};");
        writer.newLine();

        // Handler class
        writer.writeLine("/**");
        writer.writeLine(" * WebSocket handler for %s", serviceName);
        writer.writeLine(" */");
        writer.writeLine("class %s {", handlerName);
        writer.writeLine("public:");
        writer.indent();
        writer.writeLine("explicit %s(std::shared_ptr<%s> service);", handlerName, serviceName);
        writer.newLine();
        writer.writeLine("void OnConnect(std::shared_ptr<WebSocketSession> session);");
        writer.writeLine("void OnDisconnect(const std::string& session_id);");
        writer.writeLine("void OnMessage(const std::string& session_id, const WebSocketMessage& message);");
        writer.writeLine("void OnTextMessage(const std::string& session_id, const std::string& text);");
        writer.newLine();
        writer.writeLine("void Broadcast(const std::string& action, const nlohmann::json& data);");
        writer.writeLine("std::shared_ptr<WebSocketSession> GetSession(const std::string& session_id);");
        writer.writeLine("size_t SessionCount() const;");
        writer.dedent();
        writer.newLine();
        writer.writeLine("private:");
        writer.indent();
        writer.writeLine("std::shared_ptr<%s> service_;", serviceName);
        writer.writeLine("std::unordered_map<std::string, std::shared_ptr<WebSocketSession>> sessions_;");
        writer.writeLine("mutable std::mutex mutex_;");
        writer.dedent();
        writer.writeLine("};");
        writer.newLine();

        writer.writeLine("} // namespace %s", namespace);

        String headerFileName = NameUtils.toSnakeCase(serviceName) + "_websocket_handler.h";
        writer.writeToFile(includeDir.resolve(headerFileName));
    }

    private void generateWebSocketHandlerSource(Service service, SmithyModel model, String namespace, String moduleName, Path srcDir) throws IOException {
        CodeWriter writer = new CodeWriter();
        String serviceName = NameUtils.toPascalCase(service.getName());
        String handlerName = serviceName + "WebSocketHandler";

        writer.writeLine("// Code generated by smithy-cpp-generator. DO NOT EDIT.");
        writer.newLine();
        writer.writeLine("#include \"%s/%s_websocket_handler.h\"", moduleName, NameUtils.toSnakeCase(serviceName));
        writer.newLine();
        writer.writeLine("namespace %s {", namespace);
        writer.newLine();

        // Constructor
        writer.writeLine("%s::%s(std::shared_ptr<%s> service)", handlerName, handlerName, serviceName);
        writer.writeLine("    : service_(std::move(service)) {}");
        writer.newLine();

        // OnConnect
        writer.writeLine("void %s::OnConnect(std::shared_ptr<WebSocketSession> session) {", handlerName);
        writer.indent();
        writer.writeLine("std::lock_guard<std::mutex> lock(mutex_);");
        writer.writeLine("sessions_[session->id] = session;");
        for (Operation op : service.getWebSocketConnectOperations()) {
            String methodName = NameUtils.toPascalCase(op.getName());
            String inputType = op.getInput() != null
                ? NameUtils.toPascalCase(NameUtils.getSimpleName(op.getInput()))
                : null;
            if (inputType != null) {
                writer.writeLine("service_->%s(%s{});", methodName, inputType);
            } else {
                writer.writeLine("service_->%s();", methodName);
            }
        }
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();

        // OnDisconnect
        writer.writeLine("void %s::OnDisconnect(const std::string& session_id) {", handlerName);
        writer.indent();
        writer.writeLine("std::lock_guard<std::mutex> lock(mutex_);");
        writer.writeLine("sessions_.erase(session_id);");
        for (Operation op : service.getWebSocketDisconnectOperations()) {
            String methodName = NameUtils.toPascalCase(op.getName());
            String inputType = op.getInput() != null
                ? NameUtils.toPascalCase(NameUtils.getSimpleName(op.getInput()))
                : null;
            if (inputType != null) {
                writer.writeLine("service_->%s(%s{});", methodName, inputType);
            } else {
                writer.writeLine("service_->%s();", methodName);
            }
        }
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();

        // OnTextMessage
        writer.writeLine("void %s::OnTextMessage(const std::string& session_id, const std::string& text) {", handlerName);
        writer.indent();
        writer.writeLine("try {");
        writer.indent();
        writer.writeLine("auto j = nlohmann::json::parse(text);");
        writer.writeLine("WebSocketMessage message;");
        writer.writeLine("message.action = j.at(\"action\").get<std::string>();");
        writer.writeLine("if (j.contains(\"payload\")) {");
        writer.indent();
        writer.writeLine("message.payload = j.at(\"payload\");");
        writer.dedent();
        writer.writeLine("}");
        writer.writeLine("OnMessage(session_id, message);");
        writer.dedent();
        writer.writeLine("} catch (const std::exception& e) {");
        writer.indent();
        writer.writeLine("// Invalid message format");
        writer.dedent();
        writer.writeLine("}");
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();

        // OnMessage
        writer.writeLine("void %s::OnMessage(const std::string& session_id, const WebSocketMessage& message) {", handlerName);
        writer.indent();
        writer.writeLine("auto session = GetSession(session_id);");
        writer.writeLine("if (!session) return;");
        writer.newLine();

        boolean first = true;
        for (Operation op : service.getWebSocketMessageOperations()) {
            String route = op.getWebSocketRoute();
            String methodName = NameUtils.toPascalCase(op.getName());
            String inputType = op.getInput() != null
                ? NameUtils.toPascalCase(NameUtils.getSimpleName(op.getInput()))
                : null;
            String outputType = op.getOutput() != null
                ? NameUtils.toPascalCase(NameUtils.getSimpleName(op.getOutput()))
                : null;

            if (first) {
                writer.writeLine("if (message.action == \"%s\") {", route);
                first = false;
            } else {
                writer.writeLine("} else if (message.action == \"%s\") {", route);
            }
            writer.indent();

            if (inputType != null) {
                writer.writeLine("%s input;", inputType);
                writer.writeLine("from_json(message.payload, input);");
                writer.writeLine("auto result = service_->%s(input);", methodName);
            } else {
                writer.writeLine("auto result = service_->%s();", methodName);
            }

            writer.writeLine("if (result) {");
            writer.indent();
            if (outputType != null) {
                writer.writeLine("nlohmann::json response;");
                writer.writeLine("to_json(response, *result);");
                writer.writeLine("session->Send(WebSocketMessage{\"%sResponse\", response});", route);
            }
            writer.dedent();
            writer.writeLine("} else {");
            writer.indent();
            writer.writeLine("session->Send(WebSocketMessage{\"error\", {{\"message\", result.error()->what()}}});");
            writer.dedent();
            writer.writeLine("}");
            writer.dedent();
        }

        if (!first) {
            writer.writeLine("} else {");
            writer.indent();
            writer.writeLine("session->Send(WebSocketMessage{\"error\", {{\"message\", \"Unknown action: \" + message.action}}});");
            writer.dedent();
            writer.writeLine("}");
        }

        writer.dedent();
        writer.writeLine("}");
        writer.newLine();

        // Broadcast
        writer.writeLine("void %s::Broadcast(const std::string& action, const nlohmann::json& data) {", handlerName);
        writer.indent();
        writer.writeLine("std::lock_guard<std::mutex> lock(mutex_);");
        writer.writeLine("WebSocketMessage message{action, data};");
        writer.writeLine("for (const auto& [id, session] : sessions_) {");
        writer.indent();
        writer.writeLine("if (session->IsOpen()) {");
        writer.indent();
        writer.writeLine("session->Send(message);");
        writer.dedent();
        writer.writeLine("}");
        writer.dedent();
        writer.writeLine("}");
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();

        // GetSession
        writer.writeLine("std::shared_ptr<WebSocketSession> %s::GetSession(const std::string& session_id) {", handlerName);
        writer.indent();
        writer.writeLine("std::lock_guard<std::mutex> lock(mutex_);");
        writer.writeLine("auto it = sessions_.find(session_id);");
        writer.writeLine("return it != sessions_.end() ? it->second : nullptr;");
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();

        // SessionCount
        writer.writeLine("size_t %s::SessionCount() const {", handlerName);
        writer.indent();
        writer.writeLine("std::lock_guard<std::mutex> lock(mutex_);");
        writer.writeLine("return sessions_.size();");
        writer.dedent();
        writer.writeLine("}");
        writer.newLine();

        writer.writeLine("} // namespace %s", namespace);

        String fileName = NameUtils.toSnakeCase(serviceName) + "_websocket_handler.cc";
        writer.writeToFile(srcDir.resolve(fileName));
    }

    private void generateCMakeLists(String moduleName, SmithyModel model, Path outputDir) throws IOException {
        CodeWriter writer = new CodeWriter();

        writer.writeLine("# Code generated by smithy-cpp-generator. DO NOT EDIT.");
        writer.writeLine("cmake_minimum_required(VERSION 3.20)");
        writer.writeLine("project(%s)", moduleName);
        writer.newLine();
        writer.writeLine("set(CMAKE_CXX_STANDARD 23)");
        writer.writeLine("set(CMAKE_CXX_STANDARD_REQUIRED ON)");
        writer.newLine();
        writer.writeLine("find_package(nlohmann_json REQUIRED)");
        writer.newLine();
        writer.writeLine("add_library(%s", moduleName);
        writer.indent();
        writer.writeLine("src/types.cc");
        writer.writeLine("src/error.cc");
        for (Service service : model.getServices().values()) {
            String snakeName = NameUtils.toSnakeCase(service.getName());
            writer.writeLine("src/%s_handler.cc", snakeName);
        }
        writer.dedent();
        writer.writeLine(")");
        writer.newLine();
        writer.writeLine("target_include_directories(%s PUBLIC", moduleName);
        writer.indent();
        writer.writeLine("$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>");
        writer.writeLine("$<INSTALL_INTERFACE:include>");
        writer.dedent();
        writer.writeLine(")");
        writer.newLine();
        writer.writeLine("target_link_libraries(%s PUBLIC nlohmann_json::nlohmann_json)", moduleName);

        writer.writeToFile(outputDir.resolve("CMakeLists.txt"));
    }

    private void generateBazelBuild(String moduleName, SmithyModel model, Path outputDir) throws IOException {
        CodeWriter writer = new CodeWriter();

        writer.writeLine("# Code generated by smithy-cpp-generator. DO NOT EDIT.");
        writer.writeLine("load(\"@rules_cc//cc:defs.bzl\", \"cc_library\")");
        writer.newLine();
        writer.writeLine("package(default_visibility = [\"//visibility:public\"])");
        writer.newLine();
        writer.writeLine("cc_library(");
        writer.indent();
        writer.writeLine("name = \"%s\",", moduleName);
        writer.writeLine("srcs = glob([\"src/*.cc\"]),");
        writer.writeLine("hdrs = glob([\"include/%s/*.h\"]),", moduleName);
        writer.writeLine("includes = [\"include\"],");
        writer.writeLine("deps = [");
        writer.indent();
        writer.writeLine("\"@nlohmann_json//:json\",");
        writer.dedent();
        writer.writeLine("],");
        writer.dedent();
        writer.writeLine(")");

        writer.writeToFile(outputDir.resolve("BUILD.bazel"));
    }

    private String mapToCppType(String smithyType, SmithyModel model) {
        if (smithyType == null) return "void";

        String simpleName = NameUtils.getSimpleName(smithyType);

        return switch (smithyType) {
            case "smithy.api#Blob" -> "std::vector<uint8_t>";
            case "smithy.api#Boolean" -> "bool";
            case "smithy.api#String" -> "std::string";
            case "smithy.api#Byte" -> "int8_t";
            case "smithy.api#Short" -> "int16_t";
            case "smithy.api#Integer" -> "int32_t";
            case "smithy.api#Long" -> "int64_t";
            case "smithy.api#Float" -> "float";
            case "smithy.api#Double" -> "double";
            case "smithy.api#BigInteger" -> "int64_t"; // Simplified
            case "smithy.api#BigDecimal" -> "double"; // Simplified
            case "smithy.api#Timestamp" -> "std::chrono::system_clock::time_point";
            case "smithy.api#Document" -> "nlohmann::json";
            default -> {
                Optional<Shape> shape = model.getShape(simpleName);
                if (shape.isPresent()) {
                    Shape s = shape.get();
                    if (s.getType() == ShapeType.LIST || s.getType() == ShapeType.SET) {
                        yield "std::vector<" + mapToCppType(s.getTargetShape(), model) + ">";
                    } else if (s.getType() == ShapeType.MAP) {
                        yield "std::unordered_map<" + mapToCppType(s.getKeyShape(), model) + ", " +
                            mapToCppType(s.getTargetShape(), model) + ">";
                    }
                }
                yield NameUtils.toPascalCase(simpleName);
            }
        };
    }

    public static void main(String[] args) throws Exception {
        if (args.length < 2) {
            System.err.println("Usage: CppServerGenerator <model.json> <output-dir> [module-name]");
            System.exit(1);
        }

        var parser = new com.moonbase.smithy.parser.SmithyParser();
        var model = parser.parse(java.nio.file.Path.of(args[0]));
        var options = new GeneratorOptions();

        if (args.length > 2) {
            options.setModuleName(args[2]);
        }

        new CppServerGenerator().generate(model, java.nio.file.Path.of(args[1]), options);
        System.out.println("Generated C++ server code in " + args[1]);
    }
}
